-- SCRIPT_TITLE = "RV Notes from TextGrid"
-- author = "Hataori@protonmail.com",
-- versionNumber = 2,
-- Ver.1 - loads notes from Pratt textGrid object, pitch is quantized from pitch object
-- Ver.2 - added support for loading a pitch encoded in the textGrid lyrics (without pitch quantization),
--   encoding can be generated by "RV Notes to TextGrid"
--   the pitch is encoded as MIDI's note index minus 69 offset (ie 0 = A4)

local utils = require("utils")
local praat = require("praat")
local SVP = require("svp")

local NOTES = {'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'Bb', 'B'}

local SCALES = {
  ['chroma'] = 'C-C#-D-D#-E-F-F#-G-G#-A-Bb-B-',
  ['C'] = 'C-D-E-F-G-A-B-',
  ['a'] = 'C-D-E-F-G-A-B-',
  ['C#'] = 'C#-D#-F-F#-G#-Bb-C-',
  ['Db'] = 'C#-D#-F-F#-G#-Bb-C-',
  ['bb'] = 'C#-D#-F-F#-G#-Bb-C-',
  ['D'] = 'D-E-F#-G-A-B-C#-',
  ['b'] = 'D-E-F#-G-A-B-C#-',
  ['Eb'] = 'D#-F-G-G#-Bb-C-D-',
  ['c'] = 'D#-F-G-G#-Bb-C-D-',
  ['E'] = 'E-F#-G#-A-B-C#-D#-',
  ['c#'] = 'E-F#-G#-A-B-C#-D#-',
  ['F'] = 'F-G-A-Bb-C-D-E-',
  ['d'] = 'F-G-A-Bb-C-D-E-',
  ['F#'] = 'F#-G#-Bb-B-C#-D#-F-',
  ['Gb'] = 'F#-G#-Bb-B-C#-D#-F-',
  ['d#'] = 'F#-G#-Bb-B-C#-D#-F-',
  ['eb'] = 'F#-G#-Bb-B-C#-D#-F-',
  ['G'] = 'G-A-B-C-D-E-F#-',
  ['e'] = 'G-A-B-C-D-E-F#-',
  ['Ab'] = 'G#-Bb-C-C#-D#-F-G-',
  ['f'] = 'G#-Bb-C-C#-D#-F-G-',
  ['A'] = 'A-B-C#-D-E-F#-G#-',
  ['f#'] = 'A-B-C#-D-E-F#-G#-',
  ['Bb'] = 'Bb-C-D-D#-F-G-A-',
  ['g'] = 'Bb-C-D-D#-F-G-A-',
  ['B'] = 'B-C#-D#-E-F#-G#-Bb-',
  ['Cb'] = 'B-C#-D#-E-F#-G#-Bb-',
  ['g#'] = 'B-C#-D#-E-F#-G#-Bb-'
}

--------- qunatization

function HzToHalftone(hz)
  if hz<=0 then return end
  return 12 * math.log(hz / 440) / math.log(2)
end

-- halftone number from HzToHalftone, 0 = 440 Hz, scale string from SCALES
function isInScale(ht, scale)
  local cbase = math.fmod(ht + 57, 12) -- every C = 0
  local nam = NOTES[cbase + 1]
  return string.find(scale, nam.."-", 1, true)
end

-- quantize to scale
function quantizeNote(hz, scale)
  local ht = HzToHalftone(hz)
  if not ht then return end

  local qht = math.floor(ht + 0.5)
  if isInScale(qht, scale) then return qht end

  local lht, hht = qht - 1, qht + 1
  while not isInScale(lht, scale) do
    lht = lht - 1
  end

  while not isInScale(hht, scale) do
    hht = hht + 1
  end

  if math.abs(ht - lht) < math.abs(ht - hht) then
    return lht
  else
    return hht
  end
end
           -- script arguments
local arg = {...}
                                 -- show help
if #arg ~= 6 then
  print("RV: Creates notes from Praat textGrid object and loads pitch object")
  print("usage: rv notesFromTextGrid <input_grid_file> <input_pitch_file> <scale> <input_SVP_project> <track_name> <output_SVP_project>")
  return
end
                                -- args to vars
local gridFileName, pitchFileName, scaleName, inputSVP, trackName, outputSVP = arg[1], arg[2], arg[3], arg[4], arg[5], arg[6]

if not utils.fileExists(gridFileName) then
  print("Error: Cannot open the pitch file '"..gridFileName.."'")
  return
end

if not utils.fileExists(pitchFileName) then
  print("Error: Cannot open the pitch file '"..pitchFileName.."'")
  return
end

local qScale = SCALES[scaleName]
if not qScale then
  print("Error: wrong scale '"..scale.."'")
  return
end

if not utils.fileExists(inputSVP) then
  print("Error: Cannot open the input SVP file '"..inputSVP.."'")
  return
end

local grid = praat:loadFirstIntervalGridTier(gridFileName) -- textgrid instance
if not grid then
  print("Error: wrong textGrid file format")
  return
end

local pitch = praat:loadPitch(pitchFileName) -- pitch instance
if not pitch then
  print("Error: wrong pitch file format")
  return
end

local svp = SVP:loadSVP(inputSVP) -- project file

local track = svp:getTrackByName(trackName)
if not track then
  print("Error: track not found '"..trackName.."'")
  return
end

if track.mainRef.isInstrumental then
  print("Error: track is instrumental")
  return
end

local noPitchEnc = 0 -- number of notes with pitch not encoded
for _, int in ipairs(grid.data) do
  if int.tx and int.tx ~= "" and not int.tx:find("!", 1, true) and not int.tx:match("%([%d-]+%)") then
    noPitchEnc = noPitchEnc + 1
  end
end

local veam = {} -- vibrato envelope for extra events

local notes, lastNote = {}, nil
for _, int in ipairs(grid.data) do
  local frb, frt = svp:getBlickFromSeconds(int.fr), svp:getBlickFromSeconds(int.to)
                     -- normalize spaces
  if int.tx then
    int.tx = int.tx:match("^%s*(.-)%s*$") or ""
  else
    int.tx = ""
  end

  if int.tx and int.tx:find("!", 1, true) then
    table.insert(veam, frb)
    table.insert(veam, 1)

    if lastNote then
      lastNote.en = frt
    end
  elseif int.tx and int.tx ~= "" then
    local txt, pit = int.tx:match("^(.-)%s*%(([%d-]+)%)$")

    if pit then -- pitch encoded in textGrid
      lastNote = {st = frb, en = frt, pitch = tonumber(pit) + 69, lyr = txt}
      table.insert(notes, lastNote)
      table.insert(veam, frb)
      table.insert(veam, 1)
    else
      local med, cnt, unvoc = {}, 0, 0
      local t = int.fr
      while t <= int.to do
        local f0 = pitch:getPitch(t)
        if f0 > 50 then
          local qn = quantizeNote(f0, qScale)
          table.insert(med, qn)
        else
          unvoc = unvoc + 1
        end

        t = t + 0.001
        cnt = cnt + 1
      end

      if #med > 2 and (#med / cnt) > 0.5 then -- more than 50% voiced length
        table.sort(med)
        med = med[math.floor(#med / 2) + 1] -- pitch median

        lastNote = {st = frb, en = frt, pitch = med + 69, lyr = int.tx}
        table.insert(notes, lastNote)
        table.insert(veam, frb)
        table.insert(veam, 1)
      else
        lastNote = {st = frb, en = frt, lyr = int.tx}
        table.insert(notes, lastNote)
        table.insert(veam, frb)
        table.insert(veam, 1)
      end
    end -- ind if pitch
  else
    lastNote = nil
  end -- if int.tx
end -- for
                         -- vibrato envelope automation
track.mainGroup.parameters.vibratoEnv.points = veam
                         -- create notes
local newnotes = {}

for i, nt in ipairs(notes) do
  local pitch = nt.pitch
  if not pitch then
    pitch = (i < #notes and notes[i + 1].pitch) or (i > 1 and notes[i - 1].pitch) or 69
  end

  local note = {
    onset = nt.st,
    attributes = {
      dF0Vbr = 0
    },
    lyrics = nt.lyr,
    phonemes = "",
    duration = nt.en - nt.st,
    detune = 0,
    pitch = pitch
  }

  table.insert(newnotes, note)
end

track.mainGroup.notes = newnotes
                 -- reset voice params
track.mainRef.voice = {
  tF0Left = 0,
  tF0Right = 0,
  dF0Left = 0,
  dF0Right = 0,
  dF0Vbr = 0
}
                      -- create pitch automation
local pdam = {}

local minblicks, maxblicks = math.huge, 0
for i = 1, #newnotes do
  local note = newnotes[i]
  local npitch = note.pitch
  local ncents = 100 * (npitch - 69) -- A4

  local blOnset, blEnd = note.onset, note.onset + note.duration

  local tons = svp:getSecondsFromBlick(blOnset) -- start time
  local tend = svp:getSecondsFromBlick(blEnd) -- end time

  local df, f0
  local t = tons + 0.0005
  while t < tend - 0.0001 do
    f0 = pitch:getPitch(t)
    if f0 > 50 then -- voiced
      df = 1200 * math.log(f0/440)/math.log(2) - ncents -- delta f0 in cents
      table.insert(pdam, svp:getBlickFromSeconds(t))
      table.insert(pdam, df)
    end
    t = t + 0.001 -- time step
  end

  local tempo = svp:getTempoMarkAt(blOnset)
  local compensation = tempo.bpm * 6.3417442

  if i > 1 then
    local pnote = newnotes[i - 1]
    local pnpitch = pnote.pitch
    local pncents = 100 * (pnpitch - 69) -- A4
    local pblOnset, pblEnd = pnote.onset, pnote.onset + pnote.duration
    local ptons = svp:getSecondsFromBlick(pblOnset) -- start time
    local ptend = svp:getSecondsFromBlick(pblEnd) -- end time

    if pblEnd == blOnset then
      local pts = svp.automationGetPoints(pdam, blOnset, svp:getBlickFromSeconds(tons + 0.010))
      local pdif = ncents - pncents

      for _, pt in ipairs(pts) do
        local b, v = pt.b, pt.v
        local t = svp:getSecondsFromBlick(b) - tons
        local cor = 1 - (1 / (1 + math.exp(-compensation * t)))
        pdam[pt.i + 1] = v + pdif * cor
      end
    end
  end

  if i < #newnotes then
    local pnote = newnotes[i + 1]
    local pnpitch = pnote.pitch
    local pncents = 100 * (pnpitch - 69) -- A4
    local pblOnset, pblEnd = pnote.onset, pnote.onset + pnote.duration
    local ptons = svp:getSecondsFromBlick(pblOnset) -- start time
    local ptend = svp:getSecondsFromBlick(pblEnd) -- end time

    if blEnd == pblOnset then
      local pts = svp.automationGetPoints(pdam, svp:getBlickFromSeconds(tend - 0.010), blEnd - 1)
      local pdif = pncents - ncents

      for _, pt in ipairs(pts) do
        local b, v = pt.b, pt.v
        local t = svp:getSecondsFromBlick(b) - tend
        local cor = 1 / (1 + math.exp(-compensation * t))
        pdam[pt.i + 1] = v - pdif * cor
      end
    end
  end
--    am:simplify(blOnset, blEnd, 0.0001)
end
track.mainGroup.parameters.pitchDelta.points = pdam

svp:saveSVP(outputSVP)
print("done")
